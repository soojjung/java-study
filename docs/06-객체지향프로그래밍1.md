# 6장. 객체지향 프로그래밍 1

## 1. 객체지향언어

기존의 프로그래밍언어에 몇 가지 규칙을 추가한 것

### 객체지향언어의 특징 3가지

1. 코드의 재사용성
2. 유지보수
3. 중복 코드 제거

### OOP의 핵심

1. 캡슐화 - data 보호, 복잡도 ⬇️
2. 상속 - 재사용성 ⬆️ 관계
3. 추상화 - 공통 추출, 재사용 ⬆️
4. 다형성 - 하나의 타입으로 여러 객체 다루기

⇒ OOP의 장점: 변경에 유리하게 하려고. 성능 때문이 아니다.

## 2. 클래스와 객체

- 클래스: 객체를 정의해 놓은 것 (설계도)
- 객체: 클래스에 정의된 대로 생성한 것 (실체)

클래스는 그룹화 한거다. 왜 그룹으로 묶나? 복잡도 낮추려고

### 객체와 인스턴스

둘이 똑같다고 생각해도 무관

객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 잇지만, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 의미를 갖고 있다.

`클래스 → 인스턴스 (객체)`

### 객체의 구성요소

1. **속성**: 변수
2. **기능**: 메서드

```java
class Tv {
    // Tv의 속성 (멤버변수)
    String color;  // 색상
    boolean power; // 전원상태 (on/off)
    int channel;  // 채널

    // Tv의 기능 (메서드)
    void power() {
        power = !power;  // Tv를 켜거나 끄는 기능을 하는 메서드
    }

    void channelUp() {
        ++channel;       // Tv의 채널을 높이는 기능을 하는 메서드
    }

    void channelDown() {
        --channel;       // Tv의 채널을 낮추는 기능을 하는 메서드
    }
}
```

객체는? iv 집합

객체를 사용한다는 것은, 객체가 가지고 있는 속성과 기능(변수와 메서드)를 사용한다는 뜻이다. 

### 인스턴스의 생성과 사용

```java
Tv t; // 변수 t 선언
t = new Tv(); // Tv 인스턴스 생성
```

두 개 다 해줘야 인스턴스 생성된다. 위에 선언까지만 하면 안된다.

혹은 둘을 합치면 이렇게 쓸 수 있다.

```java
t = new Tv();
```

: Tv라는 설계도(클래스)로 객체를 하나 만들고 초기화해 달라

`()`는 생성자를 실제로 호출(call)한다는 의미

1. `Tv t;`
    1. Tv클래스 타입의 참조변수 t를 선언한다. 메모리에 참조변수 t를 위한 공간이 마련된다.
    2. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.
2. `t = new Tv();`
    1. `new Tv`
        1. 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다. 
        2. JVM이 힙(heap) 메모리에 Tv 객체만큼의 공간을 확보
    2. `()`
        1. 확보한 공간에 생성자 Tv를 실행해 객체 초기화
        2. 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다. 
        3. 지금은 매개변수가 없는 기본 생성자이므로 빈 괄호가 들어감
    3. `= (대입연산자)`
        1. 생성된 객체의 주소값이 참조변수 t에 저장된다. 
        2. 이제는 참조변수 t를 통해 Tv인스턴스에 접근 가능
        3. 인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다!

```
⭐ 인스턴스는 참조변수를 통해서만 다를 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.
```

### 객체 배열

많은 수의 객체를 다뤄야할 때, 배열로 다루는 것이 가능하며, 이를 “객체 배열” 이라고 한다.

객체 배열 안에는 객체가 저장되는 것은 아니고, 객체의 주소가 저장된다. 

```java
Tv[] tvArr = new Tv[3]; // 1. 참조변수 배열(객체 배열)을 생성

// 2. 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

아까와 마찬가지로 1번 객체 배열 생성까지만 하면, 참조 변수들이 만들어진 것일 뿐, 아직 객체가 저장되지는 않았다.

2번 객체를 생성해서 객체 배열의 각 요소에 저장까지 해줘야 에러가 발생하지 않는다. 

### 사용자정의 타입

이전에 클래스를 **데이터와 함수의 결합**이라고 정의했다.

이도 맞지만, 클래스를 다르게 정의내릴 수도 있다. 바로 “사용자정의 타입” 이다. 

프로그래밍언어에서 제공하는 자료형(primitive type)외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자정의 타입이라고 한다. 

자바에서 기본형의 개수가 8로 정해져 있지만, 참조형의 개수가 정해져 있지 않은 이유는 이처럼 프로그래머가 새로운 타입을 추가할 수 있기 때문이다. 

## 3. 변수와 메서드

영역은 두가지: 클래스 영역, 메서드 영역

클래스 영역 안에는 인스턴스변수(iv)와 클래스변수(cv)가 담기고

메서드 영역에는 지역변수(lv)가 담긴다. 

영역은 블록{}으로 나눈다. 

```java
class Variables 
{   // 클래스 영역
  int iv;        // 인스턴스 변수
  static int cv; // 클래스 변수 (static변수, 공유변수)
  
  void method() 
  { // 메서드 영역
    int lv = 0; // 지역변수
  }
}
```

| **분류** | **선언 위치** | **생성(메모리 할당) 시점** | **저장 영역** | **기본값 자동 초기화** | **소멸 시점** |
| --- | --- | --- | --- | --- | --- |
| **클래스 변수**(static 변수) | 클래스 영역 | 클래스가 메모리에 올라갈 때 | **Metaspace** 내 정적 필드 영역 | ✔ 
(0, false, null…) | JVM 종료 또는 해당 ClassLoader 언로드 |
| **인스턴스 변수** | 클래스 영역 | new 연산자로 객체(인스턴스) 생성될 때 | **Heap** – 각 객체마다 별도 슬롯 | ✔ | 객체가 GC 대상이 될 때 |
| **지역 변수** | 클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부) | **메서드 호출 시** (변수 선언문이 수행되었을 떄) | **Thread Stack** | ✖ 
(반드시 직접 초기화) | 블록·메서드 종료 ➜ 스택 팝 |

클래스 영역에는 명령문 들어가지 않고, 선언&정의만 해준다. 

명령문은 메서드 에만 작성한다. 

### 클래스변수와 인스턴스변수

인스턴스변수 - 개별

클래스변수 - 공통

ex) 카드에서 숫자, 무늬는 개별 변수. 폭, 높이는 공통 변수로 처리한다.

```java
class Card {
  String kind; // 무니
  int number;  // 숫자
  
  static int width = 100; // 폭
  static int height = 250; // 높이
}
```

### 메서드를 사용하는 이유

1. 높은 재사용성
2. 중복된 코드 제거
3. 프로그램의 구조화

### 메서드의 선언과 구현

| **구분** | **내용** |
| --- | --- |
| **선언 (signature)** | - 접근 제한자, 리턴 타입, 메서드명, 매개변수 목록만 명시 |
| **구현 (body)** | - 선언 뒤 { … } 내에 실제 로직 작성- 지역 변수·제어문 등 배치 |

메서드의 이름: 메서드의 이름도 변수의 명명규칙에 따라 작성하면 된다. 보통 ‘add’처럼 동사로 한다.
****

**OOP 설계 5대 원칙 ― SOLID**

| **약어** | **원칙** | **한-줄 요약** | **메서드·클래스 설계 시 체크포인트** |
| --- | --- | --- | --- |
| **S** (SRP) | **단일 책임 원칙** (Single Responsibility Principle) | 한 클래스(또는 메서드)는 오직 **하나의 작업**만 가져야 한다. | - 메서드가 여러 작업을 하지 않는가?- 이름이 “And/Or”를 포함하면 분리 고려 |
| **O** (OCP) | **개방-폐쇄 원칙** (Open/Closed Principle) | **확장에 열려** 있고 **수정에 닫혀** 있어야 한다. | - 새로운 기능을 상속·구현·위임으로 추가할 수 있는가?- if/else 대신 다형성 활용 |
| **L** (LSP) | **리스코프 치환 원칙** (Liskov Substitution Principle) | 자식 객체는 부모 타입으로 **교체**해도 프로그램이 깨지면 안 된다. | - 오버라이드 시 계약(전제조건↓, 사후조건↑)을 위반하지 않는가?- 예외 발생 범위가 부모보다 넓어지지 않는가? |
| **I** (ISP) | **인터페이스 분리 원칙** (Interface Segregation Principle) | 큰 인터페이스보단 **작고 목적-특화된** 인터페이스 다수가 낫다. | - “그 메서드 나한텐 불필요해요” 하는 구현체가 있는가?- 클라이언트마다 **필요한 기능만** 묶어 제공 |
| **D** (DIP) | **의존 역전 원칙** (Dependency Inversion Principle) | **상위 수준** 모듈이 **하위 수준** 구현에 의존하면 안 된다. 둘 다 **추상(인터페이스)** 에 의존해야 한다. | - new 키워드가 퍼져 있지 않은가?- 생성자/팩토리를 통해 인터페이스를 주입받는가? |

### **메서드에서 return 문이 하는 일**

메서드의 반환타입이 ‘void’가 아닌 경우, 구현부{} 안에 ‘return 반환값;’이 반드시 포함되어 있어야 한다. 이 문장은 작업을 수행한 결과인 반환값을 호출한 메서드로 전달하는데, 이 값의 타입은 **반환타입과 일치하거나 적어도 자동 형변환이 가능한 것**이어야 한다. 

| **구분** | **역할** | **메모** |
| --- | --- | --- |
| **값 반환** | 메서드(함수)의 **실행 결과**를 호출자에게 돌려준다. | 반환 타입이 void가 아닌 경우 *반드시* 반환값을 지정해야 함. |
| **실행 종료** | return이 실행되면 **즉시 메서드를 빠져나와** 나머지 코드는 수행하지 않는다. | void 메서드에서도 return; 한 줄로 조기 종료(early exit) 가능. |

```java
// ① 값을 반환
public int add(int a, int b) {
    return a + b;      // int 반환
}

// ② 결과가 필요 없는 작업
public void log(String msg) {
    System.out.println(msg);
    // 반환값이 없으므로 return 생략 (컴파일러가 암묵적으로 추가)
}

// ③ 조기 종료(guard clause)
public void process(User user) {
    if (user == null) {
        return;        // void 메서드에서도 사용 가능
    }
    // … 이후 로직
}
```

return은 “**결과 전달 + 즉시 종료**” 두 일을 동시에 처리한다.

### JVM의 메모리구조

**JVM(Java Virtual Machine)이란?**

(1) 바이트코드를 네이티브로 돌려 주는 실행 엔진 + (2) 힙·스택·GC까지 책임지는 종합 런타임

JVM(Java Virtual Machine)은 “코드를 실제로 돌리는 엔진” + “메모리 관리자” 두 역할을 한다.

메모리를 세 영역으로 나누어 관리하는데, 메서드영역, 힙, 호출스택이다. 

1. 메서드영역(method area)
    - 프로그램 실행 중 어떤 **클래스**가 사용되면, JVM은 해당 클래스의 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다. 이 때, 그 클래스의 **클래스변수**도 이 영역에 함께 생성된다.
2. 힙(heap)
    - **인스턴스**가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다 ,즉, **인스턴스변수**들이 생성되는 공간이다. 
3. 호출스택(call stack 또는 execution stack)
    - 호출스택은 **메서드**의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 **지역변수**들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다. 
    - 콜스택의 사이즈는 기본적으로 1M이고, 가상스레드는 1M까지 필요 없어서 더 조금씩 여러개 만들어쓴다.
    - 서버쪽에서는 가상스레드 필수..!

### 객체?

- 논리적으로는: 변수 + 메서드
- 물리적으로는: 변수 (컴퓨터는 모두 변수로 저장해)

### 재귀호출

재귀호출이란? 메서드의 내부에서 메서드 자신을 다시 호출하는 것

성능떨어지지만 쓰는 이유는? 

코드가 논리적으로 구조가 더 좋을 때 쓴다.

=> 재귀호출은 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 더 큰 경우에만 사용해야 한다. 

### 클래스 메서드(static메서드)와 인스턴스 메서드

- 클래스 메서드: iv 사용x
- 인스턴스(가 필요한) 메서드: iv 사용
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static 붙이는 것을 고려한다. 
    - static을 붙이면 메서드 호출시간이 짧아지므로 성능이 향상된다. static을 안 붙인 메서드(인스턴스메서드)는 실행시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다. 

## 4. 오버로딩

오버로딩이란? 

같은 이름의 메서드(또는 생성자)를 “매개변수 리스트”만 다르게 여러 개 선언해 두고, 

호출 시 인수 타입·개수·순서에 따라 **컴파일러가 가장 잘 맞는 버전을 골라 주는 기능**

오버로딩의 예? `print(int n), print(String s), print(double d)`

장점: 내가 신경 쓰지 않아도 컴파일러가 알아서 결정해준다.

단점: 찾는데 시간이 걸린다. (우선순위 규칙에 따라)

### 오버로딩의 조건 — 외우기

1. 메서드 이름 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야한다.
3. 반환타입 영향 x

오버로딩이 아닌거? 매개변수 이름만 다른건 아니다. 반환타입만 다른것도 오버로딩 아님

| **구분** | **꼭 기억할 포인트** |
| --- | --- |
| **정의** | 하나의 **메서드 이름**으로 **매개변수 목록(타입‧순서‧개수)**이 다른 여러 메서드를 선언하는 것 |
| **장점** | **사용자 편의**: “print” 하나만 기억하면 다양한 타입 출력 가능- **인터페이스 일관성**: 의미가 같은 작업을 이름 하나로 묶어 가독성↑ |
| **단점 / 주의** | **컴파일 시간**에 우선순위 규칙을 따라 가장 적합한 시그니처를 찾느라 약간 비용 발생- 시그니처가 너무 많으면 **가독성·유지보수** 저하 |
| **오버로딩 아닌 경우** | 매개변수 **이름만** 다른 경우- **반환 타입**만 다른 경우 |

```java
System.out.print(42);          // int
System.out.print(3.14);        // double
System.out.print("Hello");     // String
System.out.println();          // 매개변수 0개도 오버로딩
```

## 5. 생성자

생성자란? "인스턴스 초기화 메서드"

생성자 쓰는 이유? 초기화 쉽게 하려고

1. 클래스와 이름 같아야한다.
2. 리턴 값 없다.
3. 다른 생성자를 호출할 땐 **첫 줄**에 this(...) 또는 super(...)

### 생성자의 오버로딩

생성자도 **여러 개** 만들 수 있음 → 매개변수 목록이 달라야 함 (일반 메서드 오버로딩 규칙과 동일)

```java
Car c = new Car();
c.color = "white";
c.gearType = "auto";
c.door = 4;
```

⬇️ 생성자 사용

```java
Car c = new Car("white", "auto", 4);
```

but, 생성자는 유연하지 못하고 성능이 떨어진다. 

만약, white랑 auto 순서 바껴도 못잡아준다. 

그래서 생성자 요즘은 잘 안쓰려 한다. 

## 6. 변수의 초기화

변수의 초기화: 변수를 선언하고 처음으로 값을 저장하는 것

멤버변수(iv, cv)와 배열의 초기화는 선택적이지만 (자동으로 해줌),

지역변수(lv)의 초기화는 필수적이다.

``` 
기본 규칙
- Heap(인스턴스·정적) = JVM이 자동 초기화
- Stack(지역) = 개발자가 반드시 값 지정
```

### 멤버변수의 초기화 방법

1. 명시적 초기화
2. 생성자
3. 초기화 블럭

### 초기화 블럭 {}

변수의 복잡한 초기화에 사용된다. 

```java
class Lamp {
    int voltage;
    {                                 // 인스턴스 초기화 블록
        voltage = 220;
        System.out.println("공통 로직");
    }

    static {                          // static 초기화 블록
        System.loadLibrary("gpio");   // 한 번만 실행
    }
}
```

### 멤버변수의 초기화 순서

- 클래스변수의 초기화 순서: 기본값 → 명시적 → 클래스 초기화 블럭
- 인스턴스변수의 초기화 순서: 기본값 → 명시적 → 인스턴스 초기화 블럭 → 생성자
