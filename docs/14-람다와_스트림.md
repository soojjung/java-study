# 14장. 람다와 스트림

**자바의 큰 세 가지 변화**

| **버전** | **주요 기능** | **설명** |
| --- | --- | --- |
| JDK 5 | 지네릭스 (Generics) | 타입 안정성과 코드 재사용성을 높임 |
| JDK 8 | 람다식 (Lambda), 스트림(Stream), Optional 등 | **함수형 프로그래밍** 도입 |
| JDK 9 | 모듈화 시스템 (Module System) | 대규모 시스템 개발 및 배포에 유리 |

## 1. 람다식 (lamda expression)

람다식의 도입으로 인해 자바는 **객체지향 언어 + 함수형 언어** 이다.

### 람다식이란?

람다식은 “메서드를 하나의 **표현식(expression)** 으로 나타낸 것” → 이름 없는 익명 함수

### 람다식 작성법 (기본 문법)

```java
(매개변수) -> { 실행문 }
```

예시 비교

```java
// 기존 방식
int method(int i) {
    return (int)(Math.random()*5) + 1;
}

// 람다식
(i) -> (int)(Math.random()*5) + 1
```

| **구성 요소** | **설명** | **예시** |
| --- | --- | --- |
| 매개변수 | 0개 이상 가능 | (), (x), (x, y) |
| 화살표 | -> 기호 | x -> x + 1 |
| 실행문 | 한 줄이면 {} 생략 가능 | x -> x * x |

### 함수형 인터페이스

: 오직 하나의 추상 메서드만 가진 인터페이스

**왜 필요할까?**

- 람다식은 익명 메서드이므로 이걸 받아줄 타입이 필요하다.
- 자바에서는 인터페이스 타입으로 람다식을 전달한다.

예시: Runnable

```java
@FunctionalInterface
interface Runnable {
    void run();
}

Runnable r = () -> System.out.println("Run!");
```

**자바 기본 함수형 인터페이스 (java.util.function)**

| **인터페이스** | **추상 메서드** | **설명** |
| --- | --- | --- |
| Function<T, R> | R apply(T t) | T를 받아 R을 반환 |
| Predicate<T> | boolean test(T t) | T를 받아 조건 판별 |
| Consumer<T> | void accept(T t) | T를 소비하고 반환 없음 |
| Supplier<T> | T get() | 매개변수 없이 T 반환 |

### 람다식의 타입과 형변환

- 람다식 자체는 익명 함수이지만, 자바에서는 반드시 함수형 인터페이스 타입으로 저장되어야 한다.
- 예:
    
    ```java
    Function<Integer, Integer> f = x -> x * x;
    ```
    
- 형변환도 가능
    
    ```java
    Object obj = (Function<Integer, Integer>)(x -> x + 10);
    ```
    

### 외부 변수를 참조하는 람다식 (Closure)

- 람다식은 자신이 선언된 외부 영역의 지역 변수를 참조할 수 있다.
    
    ```java
    int factor = 10;
    Function<Integer, Integer> f = x -> x * factor;
    ```
    
    📌 단, 외부 변수는 **final이거나 사실상 final(값 변경 불가)** 이어야 한다.
    
    (람다 내부에서 사용된 지역 변수는 값을 변경할 수 없다.)
    

### Function의 합성과 Predicate의 결합

- Function 합성
    
    ```java
    Function<Integer, Integer> f = x -> x + 2;
    Function<Integer, Integer> g = x -> x * 3;
    
    Function<Integer, Integer> h = f.andThen(g); // (x + 2) → * 3
    System.out.println(h.apply(1)); // (1 + 2) * 3 = 9
    
    Function<Integer, Integer> h2 = f.compose(g); // (* 3) → + 2
    System.out.println(h2.apply(1)); // (1 * 3) + 2 = 5
    ```
    
- Predicate 결합
    
    ```java
    Predicate<Integer> p1 = x -> x > 0;
    Predicate<Integer> p2 = x -> x % 2 == 0;
    
    Predicate<Integer> p3 = p1.and(p2);     // 양수 & 짝수
    Predicate<Integer> p4 = p1.negate();    // 음수
    
    System.out.println(p3.test(4)); // true
    System.out.println(p4.test(-3)); // true
    ```
    

### 메서드 참조 (Method Reference)

: 기존 메서드 이름을 람다보다 더 간결하게 표현하는 문법

| **종류** | **예시** |
| --- | --- |
| static 메서드 | Integer::parseInt |
| 인스턴스 메서드 | str::toUpperCase |
| 생성자 참조 | ArrayList::new |
- 문법:
    
    ```java
    클래스이름::메서드이름
    ```
    
- 예:
    
    ```java
    Function<String, Integer> f = Integer::parseInt;
    Supplier<List<String>> s = ArrayList::new;
    ```
