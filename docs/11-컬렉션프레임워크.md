## 1. 컬렉션 프레임워크의 핵심 인터페이스

![CollectionFramework.png](/image/CollectionFramework.png)

### Collection 계열(**List·Set)과 Map 계열**

- List, Set: **단일 값을 담는** 자료구조
- Map: **Key-Value 쌍**을 담는 자료구조로, Collection을 상속하지 않음


| **인터페이스** | **설명** |
| --- | --- |
| Collection | 모든 컬렉션의 최상위 인터페이스 |
| List | 순서 O, 중복 O → 예: ArrayList, LinkedList |
| Set | 순서 X, 중복 X → 예: HashSet, TreeSet |
| Map | 키-값 쌍 저장, 키 중복 X → 예: HashMap, TreeMap |


## 2. ArrayList

- **배열 기반** 리스트
- **요소 추가/조회 빠름 (O(1)), 중간 삽입/삭제는 느림 (O(n))**
- 기본 용량 **자동 증가**
- List 인터페이스 구현
- `.add()` 하기 전엔 `get()` 불가
    ```java
    List<String> list = new ArrayList<>();
    list.add("Apple");
    ```

**✅ Array vs ArrayList 차이점**

| **항목** | Array **(배열)** | ArrayList |
| --- | --- | --- |
| **크기** | **고정** (생성 시 결정) | **가변** (자동으로 늘어남) |
| **데이터 타입** | 기본형(int[], char[]) 또는 참조형 모두 가능 | **참조형(Integer, String, 등)만 가능** |
| **제공 메서드** | **없음** (length 외엔 기본 기능만) | .add(), .remove(), .contains() 등 풍부 |
| **성능** | 더 **빠름** (단순 구조) | 약간 느림 (내부 처리, boxing 등) |
| **사용법** | 간단하지만 유연성 부족 | 다양하게 가공하기 좋음 |
| **Null 가능성** | 배열은 초기화되지 않은 요소는 0/false 등 기본값 | 객체가 없으면 null 가능 |
| **요소의 초기값** | 자동으로 기본값으로 초기화 됨 | 아무 값도 없으면 요소 없음 (null이 아님) |

**✅ 요약**

- 배열은 **정해진 크기의 고정 구조**
- ArrayList는 **유연하고 확장 가능한 리스트**
- 실무에서는 **데이터 추가/삭제가 많으면 ArrayList**, 성능이 매우 중요하거나 크기가 고정이면 Array를 주로 씁니다.

## 3. LinkedList

- 배열의 단점을 보완하기 위해서 링크드 리스트라는 자료구조가 고안되었다.
- 배열의 단점:
    1. 크기를 변경할 수 없다.
    2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. 
- **노드 기반** 리스트
- **중간 삽입/삭제가 빠름 (O(1)), 조회는 느림 (O(n))**
- 양방향 연결 구조 (Double Linked List)

### ArrayList vs. LinkedList 비교

1. **순차적으로** 추가/삭제하는 경우에는 ArrayList가빠르다. 
2. **중간에** 데이터를 추가/삭제하는 경우에는 LinkedList가 빠르다. 

| 컬렉션 | 읽기 (접근시간) | 추가 / 삭제 | 비고 |
| --- | --- | --- | --- |
| ArrayList | 빠르다 | 느리다 | 순차적인 추가삭제는 더 빠름. 비효율적인 메모리사용 |
| LinkedList | 느리다 | 빠르다 | 데이터가 많을수록 접근성이 떨어짐 |

![ArrayList_LinkedList.png](/image/arraylist_linkedlist.png)


## 4. Stack과 Queue

![Stack_Queue.png](/image/Stack_Queue.png)

스택과 큐를 구현하는데 사용된 컬렉션 클래스

- **Stack**: 순차적으로 데이터를 추가하고 삭제하기 때문에 `ArrayList`와 같은 배열 기반의 컬렉션 클래스가 적합
- **Queue**: 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로 추가/삭제가 쉬운 `LinkedList`가 적합

### Stack

Stack은 컬렉션 프레임워크 이전부터 존재하던 것이기 때문에 `ArrayList`가 아닌 `Vector`로부터 상속받아 구현하였다. 

- 마지막에 넣은 요소를 먼저 꺼냄
- push(), pop(), peek()

Stack 직접 구현하기 (예제 11-8/MyStack.java)

```java
package collections;

import java.util.*;

class MyStack<E> extends Vector {
    public Object push(Object item) {
        addElement(item);
        return item;
    }

    public Object pop() {
        Object obj = peek();
        removeElementAt(size() - 1);
        return obj;
    }

    public Object peek() {
        int len = size();

        if (len == 0)
            throw new EmptyStackException();

        return elementAt(len - 1);
    }

    public boolean empty() {
        return size() == 0;
    }

    public int search(Object o) {
        int i = lastIndexOf(o);

        if (i >= 0) {
            return size() - i;
        }

        return -1;
    }
}
```

```java
package collections;

public class StackDemo {
    public static void main(String[] args) {
        MyStack<String> stack = new MyStack<>();

        // push
        stack.push("A");
        stack.push("B");
        stack.push("C");
        System.out.println("현재 스택: " + stack);   // [A, B, C]

        // peek
        System.out.println("peek: " + stack.peek()); // C (가장 위)

        // pop
        while (!stack.empty()) {
            System.out.println("pop: " + stack.pop());
        }

        System.out.println("현재 스택: " + stack);   // []
        System.out.println("스택이 비었나요? " + stack.empty()); // true
    }
}
```

실행 결과

```bash
현재 스택: [A, B, C]
peek: C
pop: C
pop: B
pop: A
현재 스택: []
스택이 비었나요? true
```

예제 11-9/StackEx.java

```java
package collections;

import java.util.*;

public class StackEx {
    public static Stack back = new Stack();
    public static Stack forward = new Stack();

    public static void main(String[] args) {
        goURL("1.구글");
        goURL("2.야후");
        goURL("3.네이버");
        goURL("4.다음");

        printStatus();

        goBack();
        System.out.println("= '뒤로' 버튼을 누른 후 =");
        printStatus();

        goBack();
        System.out.println("= '뒤로' 버튼을 누른 후 =");
        printStatus();

        goForward();
        System.out.println("= '앞으로' 버튼을 누른 후 =");
        printStatus();

        goURL("codechobo.com");
        System.out.println("= 새로운 주소로 이동 후 =");
        printStatus();
    }

    public static void printStatus() {
        System.out.println("back:" + back);
        System.out.println("forward:" + forward);
        System.out.println("현재화면은 '" + back.peek() + "'입니다.");
        System.out.println();
    }

    public static void goURL(String url) {
        back.push(url);
        if (!forward.empty())
            forward.clear();
    }

    public static void goForward() {
        if (!forward.empty())
            back.push(forward.pop());
    }

    public static void goBack() {
        if (!back.empty())
            forward.push(back.pop());
    }
}
```

실행 결과

```bash
back:[1.구글, 2.야후, 3.네이버, 4.다음]
forward:[]
현재화면은 '4.다음'입니다.

= '뒤로' 버튼을 누른 후 =
back:[1.구글, 2.야후, 3.네이버]
forward:[4.다음]
현재화면은 '3.네이버'입니다.

= '뒤로' 버튼을 누른 후 =
back:[1.구글, 2.야후]
forward:[4.다음, 3.네이버]
현재화면은 '2.야후'입니다.

= '앞으로' 버튼을 누른 후 =
back:[1.구글, 2.야후, 3.네이버]
forward:[4.다음]
현재화면은 '3.네이버'입니다.

= 새로운 주소로 이동 후 =
back:[1.구글, 2.야후, 3.네이버, codechobo.com]
forward:[]
현재화면은 'codechobo.com'입니다.
```

### Queue

- 먼저 넣은 요소가 먼저 나감
- add(), poll(), peek()

예제 11-11/QueueEx.java

```java
public class QueueEx {
    static final int MAX_SIZE = 5; // Queue에 최대 5개까지만 저장
    static Queue q = new LinkedList();

    public static void main(String[] args) {
        System.out.println("help를 입력하면 도움말을 볼 수 있습니다.");

        while (true) {
            System.out.print(">>");
            try {
                // 화면으로부터 라인단위로 입력받는다.
                Scanner s = new Scanner(System.in);
                String input = s.nextLine().trim();

                if ("".equals(input)) continue;

                if (input.equalsIgnoreCase("q")) {
                    System.exit(0);
                } else if (input.equalsIgnoreCase("help")) {
                    System.out.println(" help - 도움말을 보여줍니다.");
                    System.out.println(" q 또는 Q - 프로그램을 종료합니다.");
                    System.out.println(" history - 최근에 입력한 명령어를 " + MAX_SIZE + "개 보여줍니다.");
                } else if (input.equalsIgnoreCase("history")) {
                    int i = 0;
                    save(input);   // 입력받은 명령어를 저장하고
                    LinkedList tmp = (LinkedList) q;
                    ListIterator it = tmp.listIterator();

                    while (it.hasNext()) {
                        System.out.println(++i + "." + it.next());
                    }
                } else {
                    save(input);
                    System.out.println(input);
                }
            } catch (Exception e) {
                System.out.println("입력오류입니다.");
            }
        }
    }

    public static void save(String input) {
        if (!"".equals(input)) {
            q.offer(input);
        }
        if (q.size() > MAX_SIZE) {
            q.remove();
        }
    }
}
```

유닉스의 history명령을 Queue를 이용해서 구현한 것이다. history명령은 사용자가 입력한 명령의 이력을 순서대로 보여준다. 여기서는 최근 5개의 명령만을 보여주도록 `MAX_SIZE` 값을 설정하였다. 만약 `MAX_SIZE`를 넘어가면 맨 처음 history가 삭제되고 뒤에 새로운 history가 추가된다. 


### 스택과 큐의 활용

```
스택의 활용 예 - 수식 계산, 수식 괄호 검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로

큐의 활용 예 - 최근 사용 문서, 인쇄작업 대기 목록, 버퍼(buffer)
```

### PriorityQueue - 우선순위 큐

Queue인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선 순위(priority)가 높은 것부터 꺼내게 된다는 특징이 있다. 그리고 null은 저장할 수 없다. null을 저장하면 NullPointerException이 발생한다. 

PriorityQueue는 저장공간으로 배열을 사용하며, 각 요소를 ‘힙(heap)’이라는 자료구조의 형태로 저장한다. 힙은 이진 트리의 한 종류로 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있다는 특징이 있다.

저장순서가 3,1,5,2,4 이여도 출력결과는 1,2,3,4,5가 나온다. 

### Deque(Double-Ended Queue) - 덱 또는 디큐

Queue의 변형으로, 양쪽 끝에 추가/삭제가 가능하다. Deque의 조상은 Queue이며, 구현체로는 `ArrayDeque`과 `LinkedList`가 있다. 


## Iterator, ListIterator, Enumeration

- Iterator는 **컬렉션(List, Set 등)을 순차적으로 탐색(반복)** 하기 위한 **인터페이스** 이다.
- 배열은 인덱스로 반복이 가능하지만, 컬렉션은 내부 구조가 다양하므로 통일된 반복 방식이 필요한데, 이럴 때 Iterator를 사용한다.
- Iterator는 자바 컬렉션 프레임워크에서 **모든 컬렉션을 동일하게 반복할 수 있도록** 만들어진 **표준 인터페이스**

```java
public interface Iterator<E> {
    boolean hasNext(); // 다음 요소가 있는가?
    E next();          // 다음 요소 반환
    void remove();     // 마지막으로 next()로 반환된 요소 삭제 (선택적 구현)
}
```

**✅ 주요 특징**

| **메서드** | **설명** |
| --- | --- |
| hasNext() | 다음 요소가 있는지 확인 (boolean) |
| next() | 다음 요소를 꺼내옴 |
| remove() | 현재 요소 삭제 (주의: next() 호출 이후에만 가능) |

> for-each문도 내부적으로 Iterator를 사용한다. 즉, for (String s : list)는 Iterator의 sugar syntax이다.
> 

**✅ 기본 사용 예시**

```java
public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Java");
        list.add("Python");
        list.add("C++");

        Iterator<String> it = list.iterator(); // iterator 얻기

        while (it.hasNext()) {
            String lang = it.next();
            System.out.println(lang);
        }
    }
}
```

**✅ Iterable vs Iterator**

| **구분** | **설명** |
| --- | --- |
| Iterable | 반복 가능한 객체의 인터페이스 (for-each 가능하게 함) |
| Iterator | 실제로 값을 하나씩 꺼내는 객체 |

```java
Iterable<String> iterable = list;
Iterator<String> it = iterable.iterator();
```

```java
public interface Iterable<T> {
    Iterator<T> iterator();
}
```

**✅ Iterator의 단점**

- **단방향 순회만 가능** (ListIterator는 양방향 가능)
- **랜덤 접근 불가** (인덱스로 접근 불가능)
- 사용 후에는 새로 생성해야 다시 반복 가능

✅ **컬렉션 프레임워크 계층 구조**

- **자바의 모든 “컬렉션(Collection)” 클래스들은 iterator() 메서드를 가지고 있음**
- 왜냐하면 모든 컬렉션 클래스들은 Iterable<E> 인터페이스를 **상속**받기 때문
- **모든 Collection 하위 클래스는 iterator() 메서드 보유!**
    - iterator() 사용 가능 클래스:
    - ArrayList, LinkedList, HashSet, TreeSet, PriorityQueue, Stack, Deque, LinkedHashSet
- 하지만 Map<K, V>은 Collection을 구현하지 않기 때문에 **직접적으로 Iterable이 아님**

| **타입** | **방향** | **수정** | **주요 메서드** |
| --- | --- | --- | --- |
| Iterator | → | 삭제만 가능 | hasNext(), next(), remove() |
| ListIterator | ←, → | 삽입/수정/삭제 가능 | add(), set() |
| Enumeration | → | 읽기 전용 | hasMoreElements(), nextElement() |


## Comparator와 Comparable

| **항목** | **Comparable** | **Comparator** |
| --- | --- | --- |
| 목적 | **기본 정렬** 기준 | **사용자 정의 정렬** |
| 위치 | 비교 로직이 클래스 내부에 있음 | 클래스 외부에서 별도로 정의 |
| 메서드 | compareTo() 메서드 오버라이딩 | compare() 메서드 별도 구현 |
| 사용 예 | Collections.sort(list) | Collections.sort(list, comparator) |

```java
// Comparable
class Student implements Comparable<Student> {
    String name;
    int score;

    Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    // 오름차순 정렬 기준
    @Override
    public int compareTo(Student other) {
        return this.score - other.score;
    }

    @Override
    public String toString() {
        return name + "(" + score + ")";
    }
}
```

```java
// Comparator
class DescendingScoreComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s2.score - s1.score; // 내림차순
    }
}
```
