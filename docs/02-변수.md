# 2장. 변수

- 변수란? 저장공간 - 크기, 타입
- 만들고, 읽고, 쓰는거 중요 
- 속도는 읽기 > 쓰기 > If > 메서드 순으로 빠르다. 
- 주소에다가 이름 붙이는거
- 사물함에 번호가 달려있고, 사물함 안에 물건 넣을 수 있다.
- 하지만 사람이 번호 외우는 거보다 이름 외우는게 쉬워서 이름을 붙인거
- 변수는 저장할때 생긴다.
- 선언: 타입 정하고 이름 짓는거
- 정의: 실제로 메모리를 할당하고 그 변수가 존재하도록 하는 것

## 변수의 명명규칙

1. 대소문자 구분됨
2. 숫자로 시작 금지
3. 특수문자는 `‘_’`와 `‘$’`만 가능
4. 예약어 사용 금지 
    - Java 예약어
        | 분류 | 예약어 예시 |
        | --- | --- |
        | 제어문 | `if`, `else`, `switch`, `case`, `for`, `while`, `do`, `break`, `continue`, `return` |
        | 선언·접근제어 | `class`, `interface`, `enum`, `public`, `private`, `protected`, `static`, `final`, `abstract` |
        | 예외처리 | `try`, `catch`, `finally`, `throw`, `throws` |
        | 기타 | `import`, `package`, `new`, `this`, `super`, `null`, `true`, `false` |

## 클래스명

1. PascalCase
2. 상수는 모두 대문자 + “_”(언더바)


## 변수의 타입

값 1을 해석하기 위해 단위가 필요하듯 (1kg, 1m, 1L)
프로그래밍에서는 타입이 단위의 역할을 한다.

```
⭐ 모든 값은 타입이 있고, 타입을 모르면 해석할 수 없다.
```

### 타입의 두 종류

1. 기본형: 
    1. 값 1개 (요소)
    2. 8개
    3. `boolean`, `byte`, `char`, `short`, `int`, `long`, `float`, `double`
    4. “**변수**”라고 부른다.
2. 참조형: 
    1. 값 여러개 (0~n개. **집합**)
    2. 무한개
    3. 구조와 인스턴스를 무한히 만들 수 있다.
    4. “**객체**”라고 부른다. (객체란? **변수 묶음**. 논리적으로는 변수+메서드)


## 기본형과 참조형

- 기본형: 변수 하나
- 참조형: 집합. 값 여러개를 묶어놓은 주소값
- 기본형은 8가지이나 컴퓨터는 숫자만 읽기 때문에 사실상 **정수형(int)과 실수형(double) 2가지만 존재**
    - 논리형: boolean
    - 문자형: char
    - 정수형: byte, short, **int**, long
    - 실수형: float, **double**

[기본형의 종류와 크기]

|  | 1 byte | 2 byte | 4 byte | 8 byte |
| --- | --- | --- | --- | --- |
| 논리형 | boolean |  |  |  |
| 문자형 |  | char |  |  |
| 정수형 | byte | short | **int** | long |
| 실수형 |  |  | float | **double** |

```java
3 + 5         // 덧셈 연산자
"java" + "8"  // 문자열 결합 연산자
```
똑같이 +를 사용하지만 둘이 다르다!

### 포맷 지정자(format specifier)

- **%**: “여기에 값이 들어갑니다”라는 표식
- **d**: **decimal integer**의 줄임말로, 정수(integer)를 10진수(decimal) 형태로 출력하라는 의미

```java
int age = 30;
printf("age:%d", age); // age:30
```

[자주 쓰이는 포맷 지정자 예시]

| 지정자 | 용도 | 예시 출력 |
| --- | --- | --- |
| `%d` | `int`을 10진수로 출력 | `42` |
| `%ld` | `long int`을 10진수로 출력 | `1234567890` |
| `%f` | `float` 혹은 `double` | `3.141593` |
| `%.2f` | 소수점 둘째 자리까지 출력 | `3.14` |

### 특수문자 이스케이프 시퀀스(escape sequence)

| 이스케이프 시퀀스 | 의미 | 예시 출력 |
| --- | --- | --- |
| `\t` | 탭(tab) | A\tB → A    B |
| `\b` | 백스페이스 (backspace) | ab\b → a |
| `\f` | 폼 피드(form feed) | (프린터 제어용) |
| `\n` | 줄바꿈 (newline) | Hello\nWorld →
Hello
World |
| `\r` | 캐리지 리턴 (carriage return) | (윈도우용 CR) |
| `\\` | 백슬래시 (backslash) | "\" → \ |
| `\'` | 작은따옴표 (single quote) | ''' → ’ |
| `\"` | 큰따옴표 (double quote) | """ → " |
| `\uXXXX` | 유니코드 문자 (`XXXX`는 16진 코드) | `\u2605` → ★ |

## 인코딩과 디코딩

- **인코딩(Encoding)**
    
    문자(유니코드 코드 포인트)를 바이트(저장·전송 단위)로 변환하는 과정
    
- **디코딩(Decoding)**
    
    바이트를 다시 문자(유니코드 코드 포인트)로 변환하는 과정
    
- 웹사이트에서 한국어 깨지는 이유? 디코딩 잘못해서

### 1. 아스키 (ASCII)

- 영문 대·소문자, 숫자, 특수문자, 제어문자 포함
- 한국어 등 비(非)영어권 문자는 표현 불가

### 2. 확장 아스키와 한글

### 3. 코드 페이지

### 4. 유니코드

- 아스키가 국가별로 만들어져서 그것들을 합친게 유니코드
- 전 세계 모든 문자를 **통일된 번호(코드 포인트)** 로 관리
- **UTF-8, UTF-16, UTF-32** 등 다양한 인코딩 방식 존재
    - **UTF-8**: 가변 길이(1~4바이트), ASCII 호환, 웹 표준
    - **UTF-16**: 2바이트 기본 단위, 일부 문자는 4바이트(서로게이트 쌍)
    - **UTF-32**: 모든 코드를 4바이트로 고정

### 👉 요약

- **인코딩·디코딩의 일치**가 무엇보다 중요
- ASCII → 확장 ASCII(EUC-KR, CP949) → 유니코드(UTF-8)로 발전
- 가능하면 **UTF-8** 사용: 호환성과 범용성이 가장 높음

## 정수형 - byte, short, int, long

### 정수형의 선택기준

- `int` 쓴다
- `int`타입의 크기는 4 byte 이므로, 표현할 수 있는 정수의 개수는 약 40억이며, 표현가능한 정수의 범위는 `-20억~+20억`이다.
- 결론적으로 정수형 변수를 선언할 때는 `int`타입으로 하고, `int`의 범위를 넘어서는 수를 다뤄야할 때는 `long`을 사용하면 된다.

### 오버플로우

- 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 연산이 발생했을 때
- 예시로 계수기 생각
- 9999 에 1을 더하면 하위 4자리만 저장할 수 있기 때문에 0000이 된다.
- 2진수일때 발생
- 오버플로우 방지하기 위해 자릿수 넉넉하게 저장

### 실수에 오차가 발생하는 이유 3가지

1. 원래 오차가 있다. 1/3 = 0.3333333..
2. 10진수 → 2진수로 변환과정에서 오차 발생 가능
3. 저장공간의 한계 (비트 수 제한)

**오버플로우 vs 부동소수점 오차**

- 오버플로우는 계산 결과가 타입 한계를 넘을 때 발생
- 부동소수점 오차는 값을 표현·저장·계산하는 과정에서 불가피하게 생기는 “근사 오차”

| 구분 | 오버플로우 | 부동소수점 오차 |
| --- | --- | --- |
| 원인 | 타입 비트 수 한계 초과 | 유한 비트로 무한 소수 표현 |
| 발생 시점 | 계산 결과가 최대·최소 범위 넘을 때 | 표현·저장·연산 과정에서 반올림/절단 시 |
| 증상 | 랩어라운드(wrap-around), 음수/양수 뒤집힘 | 0.1+0.2≠0.3 같은 미세한 오차 |
| 방지/완화 방법 | 더 넓은 타입, 오버플로우 체크, Big Integer | 배정도 사용, BigDecimal, 알고리즘 최적화 |

## 형변환

형변환이란? 변수 또는 상수의 타입을 다른 타입으로 변환하는 것

1. 정수 ↔ 실수
    1. 1 → 1.0
    2. 1.6 → 1
2. 큰 정수 ↔ 작은 정수
    1. 작은 정수 → 큰 정수 : 문제 없음
    2. 큰 정수 → 작은 정수 : **값이 잘릴 수 있음** (`long` → `int` 등)
3. 큰 실수 ↔ 작은 실수
    1. 작은 실수 → 큰 실수 : 문제 없음
    2. 큰 실수 → 작은 실수 : **값이 잘릴 수 있음** (`double` → `float` 등)

1. `boolean`을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

### 자동으로 형변환 되지 않는 경우

1. **기본형 간 Narrowing**
    
    큰 범위 → 작은 범위 변환은 항상 명시적 캐스트가 필요
    
    ```java
    double d = 3.14;
    int    i = (int)d;    // 명시적: double → int
    ```
    
2. **참조형 다운캐스팅(Downcasting)**
    
    슈퍼클래스 참조 → 서브클래스 타입으로 변환 시 반드시 명시적 캐스트
    
    ```java
    Animal a = new Dog();
    Dog    d = (Dog)a;    // 명시적: Animal → Dog
    ```
    
3. **기본형 ↔ 참조형 직접 변환 불가**
    
    예를 들어 `int i`를 `String s`로 바로 바꿀 수 없고, `String.valueOf(i)` 같은 메서드를 써야 합니다.