# 3장. 연산자

연산자란? 데이터 계산

- 연산자: 연산을 수행하는 기호
    - +, -, *, /
    - 비교 >, <, ==
    - 논리 and, or, not (교집합, 합집합, 여집합)
    - 대입
- 피연산자: 연산자의 작업 대상 (변수, 상수, 리터럴, 수식)

- 식: 반드시 결과를 반환
- 문장: 선언문, 대입문, 조건문, 반복문


### 연산자에서 중요한 3가지

1. **우선순위**
    1. 산술 > 비교 > 논리 > 대입
    2. 1항 → 2항 → 3항
        - 1항 연산자 (Unary)
            - **피연산자 1개**를 취하는 연산자
            - 예: `!a`, `a`, `+a`, `++a`, `a++`, `typeof a` 등
            - **평가 순서**가 가장 높아, 복합식 안에 있더라도 먼저 계산됩니다.

        - 2항 연산자 (Binary)
            - **피연산자 2개**를 취하는 연산자
            - 예: `a + b`, `a * b`, `a > b`, `a = b`, `a && b` 등
            - 1항 연산자가 모두 평가된 뒤에 적용됩니다.
                
        - 3항 연산자 (Ternary)
            - **피연산자 3개**를 취하는 연산자
            - JavaScript/Java 공통: `조건 ? 참일 때 값 : 거짓일 때 값`
            - 가장 마지막에 평가됩니다.
                

2. **결합규칙**
    1. 같은 우선순위의 연산자들이 여러 개 있는 경우, 어떤 순서로 연산을 수행할지에 대한 규칙
    2. 단항 연산자와 대입 연산자만 오른쪽에서 왼쪽의 순서로 수행하고, 나머지는 왼쪽에서 오른쪽으로 연산을 수행한다. 
3. **산술변환** (서로 타입 다르면 맞춰야 하니까)
    1. 둘 중에 큰 쪽으로 자동 변환
    2. `int` + `long` → `long` 으로 승격
    3. `long` + `float` → `float`으로 승격
    4. `int`보다 작으면 `(byte, short)` `int`로 변환된다. 
    
```
⭐ 연산자는
    1. 같은 타입끼리만 가능
    2. 반드시 결과를 반환
```

꼬리질문) 그럼 괄호는 연산자일까? 

답) X. 왜? 결과를 반환하지 않기 때문

괄호는 연산순서를 수동으로(내 맘대로) 바꾸려고 묶는 것

괄호 2가지: `( )`, `{ }`


## 증감 연산자 ++ --

- 전위형(prefix) 연산자
    1. 피연산자 변수의 값을 먼저 증가(또는 감소)
    2. 그 **변경된 값을** 연산 전체의 결과로 반환
    
    ```java
    int i = 5;
    int a = ++i;  
    // 먼저 i가 6으로 증가 → 그 값을 a에 대입
    // 최종: i == 6, a == 6
    ```
    
- 후위형(postfix) 연산자
    1. 현재 변수 값을 **연산 전체의 결과**로 먼저 반환
    2. 그 **이후에** 변수 값을 증가(또는 감소)
    
    ```java
    int i = 5;
    int b = i++;  
    // 먼저 b에 5 대입 → 그 다음에 i가 6으로 증가
    // 최종: i == 6, b == 5
    ```
    
- 복합 식에서의 예시
    
    ```java
    int x = 3;
    int y = ++x * 2;   // 전위: x→4, y=4*2=8
    
    int m = 3;
    int n = m++ * 2;   // 후위: n=3*2=6, 그 뒤 m→4
    ```
    

👉 언제 쓰나?

- **전위형(`++i`)**: 증가된 값을 **즉시** 써야 할 때
- **후위형(`i++`)**: 현재 값을 **먼저** 사용하고, 그 이후에 증가시킬 때

소숫점 한자리 수 반올림 방법

- 반올림: 0.5 더하고 뒤에 버리기
- 올림: 0.9 더하고 뒤에 버리기


## 산술 연산자
- 피연산자가 정수형인 경우, 나누는 수로 `0`을 사용할 수 없다. (컴파일은 정상적으로 되지만 실행 시 오류 발생)
- 나누기 연산자의 두 피연산자가 모두 `int`타입인 경우, 연산결과 역시 `int`타입이다. 반올림이 발생하지 않는다.  
- 올바른 연산결과를 얻기 위해서는 어느 한 쪽을 실수형으로 형변환해야 한다.
```java
10 / 4 = 2
```
=> 정수만 남고 소수점 이하는 버려지기 때문에 결과가 2.5가 아닌 2가 된다. 


## 비교 연산자

문자형하고 숫자형의 비교?

⇒ 둘이 타입 다르니까 바로는 비교 불가하다. 

비교 연산자도 이항 연산자 이므로 연산을 수행하기 전에 형변환을 통해 두 피연산자의 타입을 같게 맞춘 다음, 피연산자를 비교한다. 

```java
‘0’ == 0 // false
```

`char`이 `int`로 형변환되고, 비교 된다.

```java
0.1f == 0.1d // false
```

왜 false 일까?

실수형 0.1f는 저장할 때 2진수로 변환하는 과정에서 오차가 발생한다. 

`0.1f`가 내부에 저장하는 값은          약 `0.10000000149011612 (float)`

`0.1d` (또는 `0.1`)이 저장하는 값은 약 `0.10000000000000000555 (double)`

```java
float  f = 0.1f;
double d = 0.1;

   d == f 
-> d == (double)f
-> 0.10000000000000000555 == (double)0.10000000149011612
-> 0.10000000000000000555 == 0.10000000149011612
-> false 
```

`float`와 `double` 간에는 표현할 수 있는 정밀도 차이가 있어,

동일한 수(0.1)라도 내부 근사치가 달라 `==` 비교 시 거짓(false)이 나온다.

해결하기 위해서는 `double`을 `float`로 바꾸고, `float`과 `float` 끼리 비교해야 `true`가 나온다. 

`float`타입의 값을 `double`타입으로 형변환하면, 그저 가수의 빈자리를 `0`으로 채울 뿐이므로 오차가 적어지는 것이 아니다. 

### 문자열의 비교

문자열을 비교할때는 `등호(==)` 대신 `equals()` 라는 메서드를 사용한다.

`== 연산자`는 원시형을 비교할 때는 실제 값을 비교하고, 참조형을 비교할때는 참조 레퍼런스를 비교한다. (동일한 객체인지) 

하지만 `equals`는 객체 주소값이 아닌 내용이 같으면 `true`를 반환하기 때문에 문자열을 비교할때는 `equals`를 쓴다. 

만일 대소문자 구별하지 않고 비교하고 싶으면 `equalsIgnoreCase()` 를 사용하면 된다. 


```
⭐ 집합하고 논리 연산자 중요!
```

집합을 왜 활용? 규칙을 체크

체크할때 if문을 사용하여 내가 체크해야 하는데

**강타입 언어에서는 컴파일러가 타입 체크해줘**

(컴파일러안에 if문 엄청 들어간다..! 컴파일러 = if문 덩어리)

내가 if문 덩어리 쓰는 대신 컴파일러를 사용

⇒ 컴파일러를 잘 활용하면 if문 적게 쓸 수 있다. 그래서 타입 중요해. if문 없으면 코드 간단해져

## 논리 연산자

- `|| (OR결합)` - 피연산자 중 어느 **한 쪽만 true**이면 true를 결과로 얻는다.
- `&& (AND결합)` - 피연산자 **양쪽 모두 true**이어야 true를 결과로 얻는다.

### 효율적인 연산

`OR`연산의 경우, 좌측 피연산자가 `true(참)`이면 우측 피연산자의 값은 **평가하지 않는다.**

`AND`연산의 경우, 좌측 피연산자가 `false(거짓)`이면 우측 피연산자의 값은 **평가하지 않는다.**

📍Tip) `OR`연산의 경우에는 연산결과가 **‘참’일 확률이 높은 피연산자를 왼쪽에 놓아야 더 빠른 연산결과**를 얻을 수 있다.!

## 비트 연산자

- 볼 필요 없어.. 비트 연산자가 원조 였는데 나중에 더 효율적인 `&&, ||`이 나옴

이진수 연산할때 썼었음

## 조건 연산자  ? :

### **삼항연산자**

- 자바의 유일한 **삼항 연산자**로, 간단한 조건 분기식을 **한 줄**에 표현
- `if–else` 문보다 코드가 짧고, **표현식(expression)** 이므로 값(return)을 바로 받을 수 있다.
- **반환값 타입 주의:** expression1, expression2는 반드시 **같은 타입**이거나 공통으로 승격(promote) 가능한 타입이어야 한다.

```java
(조건식) ? expression1 : expression2
```

- 조건식: `boolean` 결과를 내는 식 (`x > y`, `flag`, `list.isEmpty()` 등)
- expression1: 조건식이 `true`일 때의 값
- expression2: 조건식이 `false`일 때의 값
